<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Housing Stress Map</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    #map { width:100%; height:600px; }
    #searchBar { margin: 10px; display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    input[type="text"], input[type="number"] { padding:8px; }
    button { padding:8px 12px; }
  </style>
</head>
<body>
  <h2>Housing Stress, Public Transport, Bicycle Paths & Facilities</h2>

  <div id="searchBar">
    <input type="text" id="address" placeholder="Enter an address in Victoria" size="50">
    <label>Radius (km):
      <input type="number" id="radiusKm" value="2" min="0.5" step="0.5" style="width:80px;">
    </label>
    <label><input type="checkbox" id="showFacilities" checked> Community facilities</label>
    <input type="text" id="facilitiesQuery" placeholder="Filter facilities (e.g. pool, library)" size="24">
    <button id="goBtn">Search</button>
  </div>

  <div id="map"></div>

  <script>
    let baseTraces = [];    // PT stop layers
    let layout;             // plot layout
    let allStops = [];      // raw PT stops for nearest calc

    // Load PT stops via Flask
    fetch("/api/public_transport")
      .then(res => res.json())
      .then(data => {
        const grouped = {};
        data.features.forEach(f => {
          const mode = f.properties.MODE;
          if (!grouped[mode]) grouped[mode] = { lats: [], lons: [], names: [] };
          const lat = f.geometry.coordinates[1];
          const lon = f.geometry.coordinates[0];
          grouped[mode].lats.push(lat);
          grouped[mode].lons.push(lon);
          grouped[mode].names.push(f.properties.STOP_NAME);

          allStops.push({ lat, lon, name: f.properties.STOP_NAME, mode });
        });

        const modeStyles = {
          "REGIONAL TRAIN":   { color: "red" },
          "INTERSTATE TRAIN": { color: "purple" },
          "SKYBUS":           { color: "black" },
          "METRO TRAIN":      { color: "grey" },
          "METRO TRAM":       { color: "" },
          "METRO BUS":        { color: "blue" },
          "REGIONAL COACH":   { color: "brown" },
          "REGIONAL BUS":     { color: "orange" }
        };

        baseTraces = Object.keys(grouped).map(mode => {
          const style = modeStyles[mode] || { color: "lightgrey" };
          return {
            type: "scattermapbox",
            lat: grouped[mode].lats,
            lon: grouped[mode].lons,
            text: grouped[mode].names,
            hoverinfo: "text",
            mode: "markers",
            name: mode,
            marker: { size: 7, color: style.color }
          };
        });

        layout = {
          mapbox: { style: "open-street-map", zoom: 7, center: { lat: -37.8, lon: 145.0 } },
          margin: { r:0, t:0, l:0, b:0 },
          legend: { orientation: "h", y: -0.2 }
        };

        Plotly.newPlot("map", baseTraces, layout);
      });

    // Utilities
    function haversine(lat1, lon1, lat2, lon2) {
      const R = 6371, dLat = (lat2-lat1)*Math.PI/180, dLon = (lon2-lon1)*Math.PI/180;
      const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(a));
    }

    function lineFeatureToLatLonArrays(geometry) {
      const lats = [], lons = [];
      if (geometry.type === "LineString") {
        geometry.coordinates.forEach(([lon, lat]) => { lats.push(lat); lons.push(lon); });
        lats.push(null); lons.push(null);
      } else if (geometry.type === "MultiLineString") {
        geometry.coordinates.forEach(seg => {
          seg.forEach(([lon, lat]) => { lats.push(lat); lons.push(lon); });
          lats.push(null); lons.push(null);
        });
      }
      return { lats, lons };
    }

    function buildBikeTraces(geojson) {
      if (!geojson || !geojson.features) return [];
      const groups = {};
      geojson.features.forEach(f => {
        const infra = f.properties?.InfraType || "Bicycle infrastructure";
        if (!groups[infra]) groups[infra] = { lats: [], lons: [], texts: [] };
        const { lats, lons } = lineFeatureToLatLonArrays(f.geometry);
        groups[infra].lats.push(...lats);
        groups[infra].lons.push(...lons);
        groups[infra].texts.push((f.properties?.Name || "") + (f.properties?.HwyType ? " Â· " + f.properties.HwyType : ""));
      });
      return Object.keys(groups).map(infra => ({
        type: "scattermapbox",
        mode: "lines",
        name: infra,
        lat: groups[infra].lats,
        lon: groups[infra].lons,
        hoverinfo: "text",
        text: groups[infra].texts,
        line: { width: 3 }
      }));
    }

    function buildFacilityTraces(geojson) {
    if (!geojson || !geojson.features) return { traces: [], count: 0 };

    const lats = [], lons = [], texts = [];
    for (const f of geojson.features) {
      const coords = f?.geometry?.coordinates;
      if (!Array.isArray(coords) || coords.length < 2) continue;
      const lon = Number(coords[0]), lat = Number(coords[1]);
      if (!isFinite(lat) || !isFinite(lon)) continue;
      lats.push(lat); lons.push(lon);

      const name = f.properties?.["Facility Name"] || f.properties?.["Name"] || "Facility";
      const lga  = f.properties?.["LGA Name"] || "";
      texts.push(`${name}${lga ? " â€“ " + lga : ""}`);
    }

    if (lats.length === 0) {
      return { traces: [], count: 0 };   // <- DO NOT add a legend entry if no points
    }

    return {
      count: lats.length,
      traces: [{
        type: "scattermapbox",
        mode: "markers",
        name: "Community facilities",
        lat: lats,
        lon: lons,
        text: texts,
        hoverinfo: "text",
        marker: { size: 14, symbol: "star" }  // visible + distinct
      }]
    };
  }

    // Search + plot everything
    function searchAddress() {
      const addr = document.getElementById("address").value.trim();
      const radiusKm = parseFloat(document.getElementById("radiusKm").value) || 2.0;
      const showFacilities = document.getElementById("showFacilities").checked;
      const q = (document.getElementById("facilitiesQuery").value || "").trim();
      if (!addr) return alert("Enter an address!");

      fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(addr + " Victoria Australia")}`)
        .then(res => res.json())
        .then(results => {
          if (!results.length) { alert("Address not found!"); return; }
          const lat = parseFloat(results[0].lat);
          const lon = parseFloat(results[0].lon);

          layout.mapbox.center = { lat, lon };
          layout.mapbox.zoom = 14;

          // nearest PT
          let nearest = null, minDist = Infinity;
          allStops.forEach(s => {
            const d = haversine(lat, lon, s.lat, s.lon);
            if (d < minDist) { minDist = d; nearest = s; }
          });
          const distKm = minDist.toFixed(2);

          const searchMarker = {
            type: "scattermapbox", lat:[lat], lon:[lon],
            text: ["ðŸ“ " + addr], hoverinfo: "text",
            mode: "markers", name: "Search Location",
            marker: { size: 14, color: "red" }
          };
          const nearestMarker = {
            type: "scattermapbox", lat:[nearest.lat], lon:[nearest.lon],
            text:[`Nearest Stop: ${nearest.name} (${nearest.mode})<br>Distance: ${distKm} km`],
            hoverinfo:"text", mode:"markers", name:"Nearest Stop",
            marker:{ size:14, color:"yellow" }
          };

          // Schools (by suburb parsed from display_name)
          const suburb = results[0].display_name.split(",")[2]?.trim() || "";
          const schoolsPromise = fetch(`https://discover.data.vic.gov.au/api/3/action/datastore_search?resource_id=d26bf015-a1e5-48dd-a1d6-8edd4b0a511b&q=${encodeURIComponent(suburb)}`)
            .then(res => res.json())
            .then(apiData => {
              if (!apiData.result || !apiData.result.records.length) return [];
              const lats = apiData.result.records.map(r => parseFloat(r.Y));
              const lons = apiData.result.records.map(r => parseFloat(r.X));
              const names = apiData.result.records.map(r => r.School_Name);
              return [{
                type: "scattermapbox",
                lat: lats, lon: lons, text: names,
                hoverinfo: "text", mode: "markers",
                name: "Schools", marker: { size: 10, color: "green" }
              }];
            }).catch(() => []);

          const bikesPromise = fetch(`/api/bikes_radius?lat=${lat}&lon=${lon}&radius_km=${radiusKm}`)
            .then(res => res.json())
            .then(gj => buildBikeTraces(gj))
            .catch(() => []);

          const qParam = q ? `&q=${encodeURIComponent(q)}` : "";
          const facilitiesPromise = showFacilities
            ? fetch(`/api/facilities_radius?lat=${lat}&lon=${lon}&radius_km=${radiusKm}${qParam}`)
                .then(res => res.json())
                .then(gj => buildFacilityTraces(gj))
                .catch(() => [])
            : Promise.resolve([]);

          Promise.all([schoolsPromise, bikesPromise, facilitiesPromise]).then(([schoolMarkers, bikeLines, facilityMarkers]) => {
            const traces = [
              ...baseTraces,
              searchMarker,
              nearestMarker,
              ...(schoolMarkers || []),
              ...(bikeLines || []),
              ...(facilityMarkers || [])
            ];
            Plotly.newPlot("map", traces, layout);
          });
        });
    }

    // Button + Enter key
    document.getElementById("goBtn").addEventListener("click", searchAddress);
    document.getElementById("address").addEventListener("keydown", (e) => {
      if (e.key === "Enter") searchAddress();
    });
  </script>
</body>
</html>
